from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import login, logout
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.views.decorators.http import require_http_methods
from users.forms import CustomUserCreationForm, EmployeeRegistrationForm
from django.contrib import messages
from django.http import JsonResponse
from django.utils import timezone
from django.db.models import Sum, Count, Avg, Q
from datetime import datetime, timedelta
from services.models import Service
from bookings.models import Booking, Review, Schedule
from payments.models import Payment
from users.models import Profile
import uuid
from django.core.mail import EmailMultiAlternatives
from django.template.loader import render_to_string
from django.conf import settings
from django.utils.html import strip_tags
from email.utils import formataddr


def home(request):
    services = Service.objects.all()[:6]
    return render(request, "shared/home.html", {"services": services})


def register_type_view(request):
    return render(request, "auth/register_type.html")


def register_view(request):
    if request.method == "POST":
        form = CustomUserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            messages.success(request, "Registration successful! Please log in.")
            return redirect("login")
    else:
        form = CustomUserCreationForm()
    return render(request, "auth/register.html", {"form": form})


def services_view(request):
    services = Service.objects.filter(is_active=True)
    pending_payment = None

    if request.user.is_authenticated:
        pending_payment = Booking.objects.filter(
            customer=request.user, status="pending"
        ).first()

    return render(
        request,
        "shared/services.html",
        {"services": services, "pending_payment": pending_payment},
    )


@login_required
def dashboard_view(request):
    # Handle superusers first
    if request.user.is_superuser:
        return redirect("admin_dashboard")

    # Ensure user has a profile
    from users.models import Profile

    try:
        profile = request.user.profile
    except Profile.DoesNotExist:
        # Create profile for users without one
        profile = Profile.objects.create(user=request.user, role="customer")

    if profile.role == "admin":
        return redirect("admin_dashboard")
    elif profile.role == "supervisor":
        return redirect("supervisor_dashboard")
    elif profile.is_employee():  # washers go to employee dashboard
        return redirect("employee_dashboard")
    elif profile.role == "customer":
        bookings = Booking.objects.filter(customer=request.user).order_by("-created_at")
        return render(request, "customer/dashboard.html", {"bookings": bookings})


@login_required
def admin_dashboard(request):
    # Allow superusers and admin role users
    if not request.user.is_superuser:
        try:
            if request.user.profile.role != "admin":
                return redirect("dashboard")
        except:
            return redirect("dashboard")

    today = timezone.now().date()
    week_ago = today - timedelta(days=7)
    month_ago = today - timedelta(days=30)

    # Overview Stats
    total_revenue = (
        Payment.objects.filter(status="completed").aggregate(total=Sum("amount"))[
            "total"
        ]
        or 0
    )
    monthly_revenue = (
        Payment.objects.filter(
            status="completed", created_at__date__gte=month_ago
        ).aggregate(total=Sum("amount"))["total"]
        or 0
    )
    total_bookings = Booking.objects.count()
    total_customers = User.objects.filter(profile__role="customer").count()
    total_employees = User.objects.filter(
        profile__role__in=["washer", "supervisor", "admin"]
    ).count()
    pending_approvals = User.objects.filter(
        profile__role__in=["washer", "supervisor", "admin"], profile__is_approved=False
    ).count()

    # Recent Activity
    recent_bookings = Booking.objects.select_related(
        "customer", "service", "assigned_employee__profile"
    ).order_by("-created_at")[:10]
    recent_reviews = Review.objects.select_related(
        "booking__customer", "booking__service"
    ).order_by("-created_at")[:5]

    # Service Performance
    service_stats = Service.objects.annotate(
        booking_count=Count("booking"),
        total_revenue=Sum(
            "booking__payment__amount", filter=Q(booking__payment__status="completed")
        ),
        avg_rating=Avg("booking__review__rating"),
    ).order_by("-booking_count")

    # Employee Performance
    employee_stats = (
        User.objects.filter(
            profile__role__in=["washer", "supervisor"], profile__is_approved=True
        )
        .select_related("profile")
        .annotate(
            completed_bookings=Count(
                "assigned_bookings", filter=Q(assigned_bookings__status="completed")
            ),
            avg_rating=Avg("assigned_bookings__review__rating"),
        )
        .order_by("-completed_bookings")
    )

    context = {
        "total_revenue": total_revenue,
        "monthly_revenue": monthly_revenue,
        "total_bookings": total_bookings,
        "total_customers": total_customers,
        "total_employees": total_employees,
        "pending_approvals": pending_approvals,
        "recent_bookings": recent_bookings,
        "recent_reviews": recent_reviews,
        "service_stats": service_stats,
        "employee_stats": employee_stats,
    }

    return render(request, "admin/dashboard.html", context)


@login_required
def manage_employees(request):
    if request.user.profile.role != "admin":
        return redirect("dashboard")

    employees = User.objects.filter(
        profile__role__in=["washer", "supervisor", "admin"]
    ).select_related("profile")
    pending_employees = employees.filter(profile__is_approved=False)
    approved_employees = employees.filter(profile__is_approved=True)

    context = {
        "pending_employees": pending_employees,
        "approved_employees": approved_employees,
    }

    return render(request, "admin/manage_employees.html", context)


@login_required
def approve_employee(request, user_id):
    if request.user.profile.role != "admin" and not request.user.is_superuser:
        return redirect("dashboard")

    employee = get_object_or_404(
        User, id=user_id, profile__role__in=["washer", "supervisor"]
    )
    employee.profile.is_approved = True
    employee.is_active = True  # Activate the user account
    employee.profile.save()
    employee.save()

    # Send approval email
    from django.core.mail import send_mail
    from django.conf import settings
    from django.template.loader import render_to_string

    try:
        email_content = render_to_string(
            "emails/approval_email.txt",
            {
                "employee_name": employee.get_full_name() or employee.username,
                "role": employee.profile.get_role_display(),
                "login_url": request.build_absolute_uri("/login/"),
            },
        )

        send_mail(
            subject="Employee Application Approved - Sparkling Car Wash",
            message=email_content,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[employee.email],
            fail_silently=True,
        )
    except Exception as e:
        print(
            f"Failed to send email: {e}"
        )  # Email sending failed, but approval still processed

    messages.success(
        request, f"{employee.get_full_name()} has been approved and notified via email."
    )
    return redirect("manage_employees")


@login_required
def manage_services(request):
    if request.user.profile.role != "admin":
        return redirect("dashboard")

    services = Service.objects.all().annotate(
        booking_count=Count("booking"),
        total_revenue=Sum(
            "booking__payment__amount", filter=Q(booking__payment__status="completed")
        ),
    )

    return render(request, "admin/manage_services.html", {"services": services})


@login_required
def book_service(request, service_id):
    service = get_object_or_404(Service, id=service_id)

    if request.method == "POST":
        booking = Booking.objects.create(
            customer=request.user,
            service=service,
            booking_date=request.POST["booking_date"],
            booking_time=request.POST["booking_time"],
            car_model=request.POST["car_model"],
            car_plate=request.POST["car_plate"],
            notes=request.POST.get("notes", ""),
        )

        # Send booking confirmation email
        from django.core.mail import send_mail
        from django.conf import settings
        from django.template.loader import render_to_string

        try:
            email_content = render_to_string(
                "emails/booking_confirmation.txt",
                {
                    "customer_name": request.user.get_full_name()
                    or request.user.username,
                    "service_name": service.name,
                    "booking_date": booking.booking_date,
                    "booking_time": booking.booking_time,
                    "car_model": booking.car_model,
                    "car_plate": booking.car_plate,
                    "service_price": service.price,
                    "booking_id": booking.id,
                },
            )

            send_mail(
                subject="Booking Confirmation - Sparkling Car Wash",
                message=email_content,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[request.user.email],
                fail_silently=True,
            )
        except:
            pass

        return redirect("payment", booking_id=booking.id)

    return render(request, "customer/booking_form.html", {"service": service})


@login_required
def payment_view(request, booking_id):
    booking = get_object_or_404(Booking, id=booking_id, customer=request.user)

    if request.method == "POST":
        payment_method = request.POST.get("payment_method")

        payment = Payment.objects.create(
            booking=booking,
            amount=booking.service.price,
            payment_method=payment_method,
            status="completed",
        )

        booking.status = "confirmed"
        booking.save()

        messages.success(request, "Payment successful! Your booking is confirmed.")
        return redirect("dashboard")

    return render(request, "customer/payment.html", {"booking": booking})


@login_required
def employee_dashboard(request):
    if not request.user.profile.is_employee():
        return redirect("dashboard")

    # Redirect supervisors to supervisor dashboard
    if request.user.profile.role == "supervisor":
        return redirect("supervisor_dashboard")

    # Get current work status (for washers only)
    current_work = Booking.objects.filter(
        assigned_employee=request.user, status="in_progress"
    ).first()

    assigned_bookings = Booking.objects.filter(assigned_employee=request.user).order_by(
        "-created_at"
    )

    # Only show available bookings if employee has no current work
    unassigned_bookings = []
    if not current_work:
        unassigned_bookings = Booking.objects.filter(
            assigned_employee__isnull=True, status="confirmed"
        ).order_by("-created_at")

    # Employee KPIs
    today = timezone.now().date()
    week_start = today - timedelta(days=today.weekday())
    month_start = today.replace(day=1)

    # Today's stats
    completed_today = Booking.objects.filter(
        assigned_employee=request.user,
        status="completed",
        work_completed_at__date=today,
    ).count()

    # Weekly stats
    completed_this_week = Booking.objects.filter(
        assigned_employee=request.user,
        status="completed",
        work_completed_at__date__gte=week_start,
    ).count()

    # Monthly stats
    completed_this_month = Booking.objects.filter(
        assigned_employee=request.user,
        status="completed",
        work_completed_at__date__gte=month_start,
    ).count()

    # Average rating
    avg_rating = (
        Review.objects.filter(booking__assigned_employee=request.user).aggregate(
            avg=Avg("rating")
        )["avg"]
        or 0
    )

    # Total completed jobs
    total_completed = Booking.objects.filter(
        assigned_employee=request.user, status="completed"
    ).count()

    context = {
        "assigned_bookings": assigned_bookings,
        "unassigned_bookings": unassigned_bookings,
        "current_work": current_work,
        "completed_today": completed_today,
        "completed_this_week": completed_this_week,
        "completed_this_month": completed_this_month,
        "avg_rating": round(avg_rating, 1),
        "total_completed": total_completed,
    }

    return render(request, "employee/employee_dashboard.html", context)


@login_required
def analytics_dashboard(request):
    # Allow only supervisors and admins
    if not request.user.is_superuser:
        try:
            if request.user.profile.role not in ["admin", "supervisor"]:
                return redirect("dashboard")
        except:
            return redirect("dashboard")

    today = timezone.now().date()
    week_ago = today - timedelta(days=7)
    month_ago = today - timedelta(days=30)

    # Revenue Analytics
    total_revenue = (
        Payment.objects.filter(status="completed").aggregate(total=Sum("amount"))[
            "total"
        ]
        or 0
    )

    monthly_revenue = (
        Payment.objects.filter(
            status="completed", created_at__date__gte=month_ago
        ).aggregate(total=Sum("amount"))["total"]
        or 0
    )

    weekly_revenue = (
        Payment.objects.filter(
            status="completed", created_at__date__gte=week_ago
        ).aggregate(total=Sum("amount"))["total"]
        or 0
    )

    # Booking Analytics
    total_bookings = Booking.objects.count()
    completed_bookings = Booking.objects.filter(status="completed").count()
    pending_bookings = Booking.objects.filter(status="pending").count()

    # Service Popularity
    service_stats = Service.objects.annotate(
        booking_count=Count("booking"),
        total_revenue=Sum(
            "booking__payment__amount", filter=Q(booking__payment__status="completed")
        ),
    ).order_by("-booking_count")

    # Customer Retention
    repeat_customers = (
        Booking.objects.values("customer")
        .annotate(booking_count=Count("id"))
        .filter(booking_count__gt=1)
        .count()
    )

    total_customers = Booking.objects.values("customer").distinct().count()
    retention_rate = (
        (repeat_customers / total_customers * 100) if total_customers > 0 else 0
    )

    # Average Rating
    avg_rating = Review.objects.aggregate(avg=Avg("rating"))["avg"] or 0

    # Recent Reviews
    recent_reviews = Review.objects.select_related(
        "booking__customer", "booking__service"
    ).order_by("-created_at")[:5]

    context = {
        "total_revenue": total_revenue,
        "monthly_revenue": monthly_revenue,
        "weekly_revenue": weekly_revenue,
        "total_bookings": total_bookings,
        "completed_bookings": completed_bookings,
        "pending_bookings": pending_bookings,
        "service_stats": service_stats,
        "retention_rate": round(retention_rate, 1),
        "avg_rating": round(avg_rating, 1),
        "recent_reviews": recent_reviews,
    }

    return render(request, "analytics/dashboard.html", context)


@login_required
def add_review(request, booking_id):
    booking = get_object_or_404(
        Booking, id=booking_id, customer=request.user, status="completed"
    )

    if hasattr(booking, "review"):
        messages.info(request, "You have already reviewed this service.")
        return redirect("dashboard")

    if request.method == "POST":
        Review.objects.create(
            booking=booking,
            rating=request.POST["rating"],
            comment=request.POST.get("comment", ""),
        )
        messages.success(request, "Thank you for your review!")
        return redirect("dashboard")

    return render(request, "customer/add_review.html", {"booking": booking})


@login_required
def update_booking_status(request, booking_id):
    if not request.user.profile.is_employee():
        return redirect("dashboard")

    booking = get_object_or_404(Booking, id=booking_id, assigned_employee=request.user)

    if request.method == "POST":
        new_status = request.POST.get("status")
        booking.status = new_status

        if new_status == "in_progress":
            booking.work_started_at = timezone.now()
        elif new_status == "completed":
            booking.work_completed_at = timezone.now()

        booking.save()
        messages.success(
            request, f"Booking status updated to {booking.get_status_display()}"
        )

    return redirect("employee_dashboard")


def employee_register_view(request):
    if request.method == "POST":
        form = EmployeeRegistrationForm(request.POST)
        if form.is_valid():
            user = form.save()
            messages.success(request, "Employee registration submitted for approval.")
            return redirect("login")
    else:
        form = EmployeeRegistrationForm()

    return render(request, "auth/employee_register.html", {"form": form})


@login_required
def reject_employee(request, user_id):
    if request.user.profile.role != "admin" and not request.user.is_superuser:
        return redirect("dashboard")

    employee = get_object_or_404(
        User, id=user_id, profile__role__in=["washer", "supervisor"]
    )

    # Send rejection email before deleting
    from django.core.mail import send_mail
    from django.conf import settings
    from django.template.loader import render_to_string

    try:
        email_content = render_to_string(
            "emails/rejection_email.txt",
            {
                "employee_name": employee.get_full_name() or employee.username,
                "role": employee.profile.get_role_display(),
            },
        )

        send_mail(
            subject="Employee Application Status - Sparkling Car Wash",
            message=email_content,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[employee.email],
            fail_silently=True,
        )
    except:
        pass

    employee_name = employee.get_full_name() or employee.username
    employee.delete()  # Remove the rejected application

    messages.success(
        request, f"{employee_name} has been rejected and notified via email."
    )
    return redirect("manage_employees")
    username = request.GET.get("username")
    available = not User.objects.filter(username=username).exists()
    return JsonResponse({"available": available})


def check_email(request):
    email = request.GET.get("email")
    available = not User.objects.filter(email=email).exists()
    return JsonResponse({"available": available})


@login_required
def claim_booking(request, booking_id):
    if not request.user.profile.is_employee():
        return redirect("dashboard")

    # Check if employee has current work in progress
    current_work = Booking.objects.filter(
        assigned_employee=request.user, status="in_progress"
    ).first()

    if current_work:
        messages.warning(
            request,
            f"You must complete your current job (#{current_work.ticket_number}) before claiming a new one.",
        )
        return redirect("employee_dashboard")

    booking = get_object_or_404(
        Booking, id=booking_id, status="confirmed", assigned_employee__isnull=True
    )
    booking.assigned_employee = request.user
    booking.status = "assigned"
    booking.save()

    messages.success(request, f"You have claimed booking #{booking.ticket_number}")
    return redirect("employee_dashboard")


@login_required
def complete_booking(request, booking_id):
    if not request.user.profile.is_employee():
        return redirect("dashboard")

    booking = get_object_or_404(
        Booking, id=booking_id, assigned_employee=request.user, status="in_progress"
    )

    if request.method == "POST":
        completion_notes = request.POST.get("completion_notes", "")
        quality_check = request.POST.get("quality_check") == "on"

        booking.status = "pending_approval"  # Changed from 'completed'
        booking.work_completed_at = timezone.now()
        booking.notes = (
            f"{booking.notes}\n\nCompletion Notes: {completion_notes}"
            if booking.notes
            else f"Completion Notes: {completion_notes}"
        )
        booking.save()

        messages.success(
            request, f"Job #{booking.ticket_number} submitted for supervisor approval!"
        )
        return redirect("employee_dashboard")

    return render(request, "employee/complete_booking.html", {"booking": booking})


@login_required
def supervisor_dashboard(request):
    if request.user.profile.role != "supervisor":
        return redirect("dashboard")

    # Jobs pending approval
    pending_jobs = Booking.objects.filter(status="pending_approval").order_by(
        "-work_completed_at"
    )

    # All bookings for stats
    today = timezone.now().date()
    week_start = today - timedelta(days=today.weekday())
    month_start = today.replace(day=1)

    # Stats
    total_bookings = Booking.objects.count()
    completed_today = Booking.objects.filter(
        status="completed", work_completed_at__date=today
    ).count()
    pending_approval = Booking.objects.filter(status="pending_approval").count()
    in_progress = Booking.objects.filter(status="in_progress").count()

    # Employee performance
    employee_stats = (
        User.objects.filter(profile__role="washer")
        .annotate(
            completed_jobs=Count(
                "assigned_bookings", filter=Q(assigned_bookings__status="completed")
            ),
            avg_rating=Avg("assigned_bookings__review__rating"),
        )
        .order_by("-completed_jobs")
    )

    context = {
        "pending_jobs": pending_jobs,
        "total_bookings": total_bookings,
        "completed_today": completed_today,
        "pending_approval": pending_approval,
        "in_progress": in_progress,
        "employee_stats": employee_stats,
    }

    return render(request, "employee/supervisor_dashboard.html", context)


@login_required
def approve_job(request, booking_id):
    if request.user.profile.role != "supervisor":
        return redirect("dashboard")

    booking = get_object_or_404(Booking, id=booking_id, status="pending_approval")
    booking.status = "completed"
    booking.save()

    try:
        send_pickup_notification(booking)
        messages.success(
            request,
            f"Job #{booking.ticket_number} approved - customer notified for pickup",
        )
    except Exception as e:
        print(f"Pickup notification failed: {e}")
        messages.success(
            request, f"Job #{booking.ticket_number} approved and completed!"
        )

    return redirect("supervisor_dashboard")


@login_required
def reject_job(request, booking_id):
    if request.user.profile.role != "supervisor":
        return redirect("dashboard")

    booking = get_object_or_404(Booking, id=booking_id, status="pending_approval")
    booking.status = "in_progress"  # Send back to employee
    booking.save()

    messages.warning(request, f"Job #{booking.ticket_number} sent back for rework!")
    return redirect("supervisor_dashboard")


@login_required
def book_service(request, service_id):
    service = get_object_or_404(Service, id=service_id, is_active=True)

    if request.method == "POST":
        booking = Booking.objects.create(
            customer=request.user,
            service=service,
            booking_date=request.POST["booking_date"],
            booking_time=request.POST["booking_time"],
            car_model=request.POST["car_model"],
            car_plate=request.POST["car_plate"],
            notes=request.POST.get("notes", ""),
        )

        Payment.objects.create(
            booking=booking, amount=service.price, transaction_id=str(uuid.uuid4())
        )

        return redirect("payment", booking_id=booking.id)

    return render(request, "customer/booking_form.html", {"service": service})


@login_required
def payment_view(request, booking_id):
    booking = get_object_or_404(Booking, id=booking_id, customer=request.user)
    payment = get_object_or_404(Payment, booking=booking)
    return render(
        request, "customer/payment.html", {"booking": booking, "payment": payment}
    )


@login_required
def process_payment(request, booking_id):
    if request.method == "POST":
        booking = get_object_or_404(Booking, id=booking_id, customer=request.user)
        payment = get_object_or_404(Payment, booking=booking)

        payment_method = request.POST.get("payment_method", "mpesa")
        payment.payment_method = payment_method
        payment.status = "completed"
        payment.completed_at = timezone.now()
        payment.save()

        booking.status = "confirmed"
        booking.save()

        # Send confirmation email
        try:
            from notifications.utils import send_booking_confirmation

            send_booking_confirmation(booking)
        except Exception as e:
            print(f"Email sending failed: {e}")

        messages.success(
            request,
            "Payment successful! Booking confirmed. Check your email for confirmation.",
        )
        return JsonResponse({"success": True, "redirect_url": "/dashboard/"})

    return JsonResponse({"success": False})


@require_http_methods(["GET"])
def check_username(request):
    username = request.GET.get("username", "").strip()
    if not username:
        return JsonResponse({"available": True})

    exists = User.objects.filter(username__iexact=username).exists()
    return JsonResponse({"available": not exists})


@require_http_methods(["GET"])
def check_email(request):
    email = request.GET.get("email", "").strip()
    if not email:
        return JsonResponse({"available": True})

    exists = User.objects.filter(email=email).exists()
    return JsonResponse({"available": not exists})


def logout_view(request):
    logout(request)
    return redirect("login")


def employee_register_view(request):
    if request.method == "POST":
        form = EmployeeRegistrationForm(request.POST)
        if form.is_valid():
            user = form.save()
            messages.success(
                request,
                "Employee registration submitted! Please wait for admin approval.",
            )
            return redirect("login")
    else:
        form = EmployeeRegistrationForm()
    return render(request, "auth/employee_register.html", {"form": form})


@login_required
def employee_dashboard(request):
    if not request.user.profile.is_employee():
        messages.error(request, "Access denied. Employee account required.")
        return redirect("dashboard")

    if not request.user.profile.is_approved:
        messages.warning(request, "Your account is pending approval.")
        return redirect("home")

    # Get bookings for employee
    assigned_bookings = Booking.objects.filter(assigned_employee=request.user)
    available_bookings = Booking.objects.filter(
        status__in=["confirmed", "pending"], assigned_employee=None
    ).exclude(status="cancelled")

    return render(
        request,
        "employee/employee_dashboard.html",
        {
            "assigned_bookings": assigned_bookings,
            "available_bookings": available_bookings,
        },
    )


@login_required
def claim_booking(request, booking_id):
    if not request.user.profile.is_employee() or not request.user.profile.is_approved:
        return JsonResponse({"success": False, "error": "Access denied"})

    booking = get_object_or_404(
        Booking, id=booking_id, status="confirmed", assigned_employee=None
    )
    booking.assigned_employee = request.user
    booking.status = "assigned"
    booking.save()

    messages.success(request, f"Booking #{booking.ticket_number} claimed successfully!")
    return JsonResponse({"success": True})


@login_required
def update_booking_status(request, booking_id):
    if not request.user.profile.is_employee():
        return JsonResponse({"success": False, "error": "Access denied"})

    booking = get_object_or_404(Booking, id=booking_id, assigned_employee=request.user)
    new_status = request.POST.get("status")

    if new_status in ["in_progress", "completed"]:
        booking.status = new_status
        if new_status == "in_progress" and not booking.work_started_at:
            from django.utils import timezone

            booking.work_started_at = timezone.now()
        elif new_status == "completed":
            from django.utils import timezone

            booking.work_completed_at = timezone.now()

        booking.save()

        # Send notification email to customer
        try:
            from notifications.utils import send_status_update

            send_status_update(booking)
        except Exception as e:
            print(f"Email sending failed: {e}")

        messages.success(
            request, f"Booking #{booking.ticket_number} status updated to {new_status}!"
        )
        return JsonResponse({"success": True})

    return JsonResponse({"success": False, "error": "Invalid status"})


def send_pickup_notification(booking):
    subject = f"Your car is ready for pickup - Job #{booking.ticket_number}"
    message = f"""Hi {booking.customer.first_name},

Great news! Your car wash service has been completed and approved.

Job Details:
- Ticket Number: #{booking.ticket_number}
- Service: {booking.service.name}

Your car is now ready for pickup at your convenience.

Thank you for choosing our service!"""

    send_mail(
        subject,
        message,
        settings.DEFAULT_FROM_EMAIL,
        [booking.customer.email],
        fail_silently=False,
    )


@login_required
def update_booking_status(request, booking_id):
    if not request.user.profile.is_employee():
        return redirect("dashboard")

    booking = get_object_or_404(Booking, id=booking_id, assigned_employee=request.user)
    new_status = request.POST.get("status")

    if new_status in ["in_progress", "completed"]:
        booking.status = new_status

        if new_status == "in_progress" and not booking.work_started_at:
            booking.work_started_at = timezone.now()
            messages.success(request, f"Started work on job #{booking.ticket_number}")
        elif new_status == "completed":
            booking.work_completed_at = timezone.now()
            messages.success(request, f"Job #{booking.ticket_number} completed!")

        booking.save()
        return redirect("employee_dashboard")

    return JsonResponse({"success": False, "error": "Invalid status"})


@login_required
def approve_booking(request, booking_id):
    if not (request.user.profile.is_supervisor() or request.user.profile.is_admin()):
        return redirect("dashboard")

    booking = get_object_or_404(Booking, id=booking_id)
    booking.status = "ready_for_pickup"
    booking.approved_at = timezone.now()
    booking.approved_by = request.user
    booking.save()

    try:
        send_pickup_notification(booking)
        messages.success(
            request,
            f"Job #{booking.ticket_number} approved - customer notified for pickup",
        )
    except Exception as e:
        print(f"Pickup notification failed: {e}")
        messages.success(request, f"Job #{booking.ticket_number} approved")

    return redirect("supervisor_dashboard")


@login_required
def assign_job(request, booking_id):
    if request.user.profile.role != "supervisor":
        return redirect("dashboard")

    if request.method == "POST":
        employee_id = request.POST.get("employee_id")
        booking = get_object_or_404(Booking, id=booking_id)
        employee = get_object_or_404(User, id=employee_id, profile__role="washer")

        booking.assigned_employee = employee
        booking.status = "assigned"
        booking.save()

        messages.success(
            request, f"Job #{booking.ticket_number} assigned to {employee.username}"
        )

    return redirect("supervisor_dashboard")
